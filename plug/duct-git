# vim: set ft=sh syn=bash :
# shellcheck shell=bash

#
# Copyright (C) 2022-2023 Chris 'sh0shin' Frage
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License, version 3,
# as published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#

# @plug duct-git
# @desc Git operations.

# @pvar Git binary.
declare -g DUCT_GIT_BINARY="${DUCT_GIT_BINARY:-"git"}"

# @pvar Git LFS binary.
declare -g DUCT_GIT_LFS_BINARY="${DUCT_GIT_LFS_BINARY:-"git-lfs"}"

# @pvar Git working directory.
declare -g DUCT_GIT_WORKDIR="${DUCT_GIT_WORKDIR:-"$PWD"}"

# @pvar Default git branch name.
declare -g DUCT_GIT_BRANCH="${DUCT_GIT_BRANCH:-"main"}"

# @pvar Default git remote name.
declare -g DUCT_GIT_REMOTE="${DUCT_GIT_REMOTE:-"origin"}"

# git local head

declare -g DUCT_GIT_LOCAL_HEAD_PATH="${DUCT_GIT_LOCAL_HEAD_PATH:-$DUCT_GIT_WORKDIR}"

# deps: duct-msg
# intl: false
# life: core
# desc: Return current local HEAD.
# opts:
__duct_git_local_head() {
  local LOCAL_HEAD

  if [[ -d "${DUCT_GIT_LOCAL_HEAD_PATH}/.git" ]]
  then
    LOCAL_HEAD="$( __duct_run git -C "$DUCT_GIT_LOCAL_HEAD_PATH" describe --all 2>/dev/null )"
    LOCAL_HEAD="${LOCAL_HEAD##*/}"
    __duct_msg d "$LOCAL_HEAD"
    echo "$LOCAL_HEAD"
    return
  else
    __duct_msg e "'$DUCT_GIT_LOCAL_HEAD_PATH' not a git repository!"
    return 1
  fi
}

# git local branch

declare -g -a -x DUCT_GIT_LOCAL_BRANCH_LIST=()

declare -g DUCT_GIT_LOCAL_BRANCH_PATH="${DUCT_GIT_LOCAL_BRANCH_PATH:-$DUCT_GIT_WORKDIR}"

declare -g DUCT_GIT_LOCAL_BRANCH_NAME="${DUCT_GIT_LOCAL_BRANCH_NAME:-}"

__duct_git_local_branch() {
  readarray -t DUCT_GIT_LOCAL_BRANCH_LIST < <( __duct_run git -C "$DUCT_GIT_LOCAL_BRANCH_PATH" branch --no-color --list --format='%(refname:lstrip=2)' )

  __duct_msg d "${DUCT_GIT_LOCAL_BRANCH_LIST[*]}"
}

# git remote branch

declare -g -a -x DUCT_GIT_REMOTE_BRANCH_LIST=()

declare -g DUCT_GIT_REMOTE_BRANCH_PATH="${DUCT_GIT_REMOTE_BRANCH_PATH:-$DUCT_GIT_WORKDIR}"

declare -g DUCT_GIT_REMOTE_BRANCH_NAME="${DUCT_GIT_REMOTE_BRANCH_NAME:-}"

__duct_git_remote_branch() {
  readarray -t DUCT_GIT_REMOTE_BRANCH_LIST < <( __duct_run git -C "$DUCT_GIT_REMOTE_BRANCH_PATH" branch --remote --no-color --list --format='%(refname:lstrip=3)' )

  __duct_msg d "${DUCT_GIT_REMOTE_BRANCH_LIST[*]}"
}

# git remote head

declare -g DUCT_GIT_REMOTE_HEAD_PATH="${DUCT_GIT_REMOTE_HEAD_PATH:-$DUCT_GIT_WORKDIR}"

declare -g DUCT_GIT_REMOTE_HEAD_REMOTE="${DUCT_GIT_REMOTE_HEAD_REMOTE:-$DUCT_GIT_REMOTE}"

# deps: duct-msg
# intl: false
# life: core
# desc: Return current remote HEAD.
# opts:
__duct_git_remote_head() {
  local REMOTE_HEAD

  if [[ -d "${DUCT_GIT_REMOTE_HEAD_PATH}/.git" ]]
  then
    # shellcheck disable=SC2046
    set -- $( __duct_run git -C "$DUCT_GIT_REMOTE_HEAD_PATH" ls-remote --symref "$DUCT_GIT_REMOTE_HEAD_REMOTE" HEAD )

    if [[ "${1:-}" == "ref:" ]]
    then
      REMOTE_HEAD="${2##*/}"
    else
      __duct_msg w "no remote head!"
      return
    fi

    __duct_msg d "$REMOTE_HEAD"
    echo "$REMOTE_HEAD"
    return
  else
    __duct_msg d "'$DUCT_GIT_REMOTE_HEAD_PATH' not a git repository!"
    return 1
  fi
}

# git config

# Git configuration file (inherit GIT_CONFIG).
declare -g DUCT_GIT_CONFIG_FILE="${DUCT_GIT_CONFIG_FILE:-"${GIT_CONFIG:-"${HOME}/.gitconfig"}"}"

# Git user.name configuration (inherit GIT_USER_NAME).
declare -g DUCT_GIT_CONFIG_USER_NAME="${DUCT_GIT_CONFIG_USER_NAME:-"${GIT_USER_NAME:-}"}"

# Git user.email configuration (inherit GIT_USER_EMAIL).
declare -g DUCT_GIT_CONFIG_USER_EMAIL="${DUCT_GIT_CONFIG_USER_EMAIL:-"${GIT_USER_EMAIL:-}"}"

# Git init.defaultBranch configuration (inherit DUCT_GIT_BRANCH).
declare -g DUCT_GIT_CONFIG_INIT_DEFAULT_BRANCH="${DUCT_GIT_CONFIG_INIT_DEFAULT_BRANCH:-$DUCT_GIT_BRANCH}"

# Git advice.detachedHead configuration.
declare -g DUCT_GIT_CONFIG_ADVICE_DETACHED_HEAD="${DUCT_GIT_CONFIG_ADVICE_DETACHED_HEAD:-false}"

# Array of Git custom configurations (TODO).
#declare -g -a DUCT_GIT_CONFIG_CUSTOM=( "${DUCT_GIT_CONFIG_CUSTOM[@]}" )

# deps: duct-msg duct-run
# intl: false
# life: core
# desc: Create a minimal git configuration.
# opts:
__duct_git_config() {
  local GIT_ERROR=0

  if [[ -z "$DUCT_GIT_CONFIG_USER_NAME" ]]
  then
    __duct_msg e "DUCT_GIT_CONFIG_USER_NAME is unset!"
    (( GIT_ERROR+=1 ))
  fi

  if [[ -z "$DUCT_GIT_CONFIG_USER_EMAIL" ]]
  then
    __duct_msg e "DUCT_GIT_CONFIG_USER_EMAIL is unset!"
    (( GIT_ERROR+=1 ))
  fi

  if [[ "$GIT_ERROR" -gt 0 ]]
  then
    return 1
  fi

  local _DEFAULT_BRANCH
  local _USER_NAME
  local _USER_EMAIL

  _DEFAULT_BRANCH="$(git config --get init.defaultBranch || :)"
  if [[ -z "$_DEFAULT_BRANCH" ]]
  then
    __duct_msg d "no default branch!"
  else
    __duct_msg d "current default branch: '$_DEFAULT_BRANCH'"
  fi

  _USER_NAME="$(git config --get user.name || :)"
  if [[ -z "$_USER_NAME" ]]
  then
    __duct_msg d "no user name!"
  else
    __duct_msg d "current user name: '$_USER_NAME'"
  fi

  _USER_EMAIL="$(git config --get user.email || :)"
  if [[ -z "$_USER_EMAIL" ]]
  then
    __duct_msg d "no user email!"
  else
    __duct_msg d "user email: '$_USER_EMAIL'"
  fi

  _ADVICE_DETACHED_HEAD="$( git config --get advice.detachedHead || : )"
  if [[ -z "$_ADVICE_DETACHED_HEAD" ]]
  then
    __duct_msg d "no advice detachedHead!"
  else
    __duct_msg d "advice detachedHead: '$_ADVICE_DETACHED_HEAD'"
  fi

  if [[ "$DUCT_GIT_CONFIG_INIT_DEFAULT_BRANCH" != "$_DEFAULT_BRANCH" ]]
  then
    __duct_msg n "setting default branch: '$_DEFAULT_BRANCH' to '$DUCT_GIT_CONFIG_INIT_DEFAULT_BRANCH'"
    GIT_CONFIG="$DUCT_GIT_CONFIG_FILE" \
    __duct_run git config init.defaultBranch "$DUCT_GIT_CONFIG_INIT_DEFAULT_BRANCH"
  fi

  if [[ "$DUCT_GIT_CONFIG_USER_NAME" != "$_USER_NAME" ]]
  then
    __duct_msg n "setting user name: '$_USER_NAME' to '$DUCT_GIT_CONFIG_USER_NAME'"
    GIT_CONFIG="$DUCT_GIT_CONFIG_FILE" \
    __duct_run git config user.name "$DUCT_GIT_CONFIG_USER_NAME"
  fi

  if [[ "$DUCT_GIT_CONFIG_USER_EMAIL" != "$_USER_EMAIL" ]]
  then
    __duct_msg n "setting user email: '$_USER_EMAIL' to '$DUCT_GIT_CONFIG_USER_EMAIL'"
    GIT_CONFIG="$DUCT_GIT_CONFIG_FILE" \
    __duct_run git config user.email "$DUCT_GIT_CONFIG_USER_EMAIL"
  fi

  if [[ "$DUCT_GIT_CONFIG_ADVICE_DETACHED_HEAD" != "$_ADVICE_DETACHED_HEAD" ]]
  then
    __duct_msg n "setting advice detachedHead: '$_ADVICE_DETACHED_HEAD' to '$DUCT_GIT_CONFIG_ADVICE_DETACHED_HEAD'"
    GIT_CONFIG="$DUCT_GIT_CONFIG_FILE" \
    __duct_run git config advice.detachedHead "$DUCT_GIT_CONFIG_ADVICE_DETACHED_HEAD"
  fi

  # TODO: DUCT_GIT_CONFIG_CUSTOM
}

# git credential

# Git URL to set credential for.
declare -g DUCT_GIT_CREDENTIAL_SERVER="${DUCT_GIT_CREDENTIAL_SERVER:-}"

# Token, base64 is supported.
declare -g DUCT_GIT_CREDENTIAL_TOKEN="${DUCT_GIT_CREDENTIAL_TOKEN:-}"

# Username (commonly unused with token).
declare -g DUCT_GIT_CREDENTIAL_USER="${DUCT_GIT_CREDENTIAL_USER:-"git"}"

# deps: duct-msg duct-run duct-util
# intl: false
# life: core
# desc: Configure git credential helper and create a credentials file.
# opts:
__duct_git_credential() {
  local GIT_ERROR=0
  local GIT_CREDENTIAL_FILE="${HOME}/.git-credentials"

  if [[ -z "$DUCT_GIT_CREDENTIAL_TOKEN" ]]
  then
    __duct_msg e "DUCT_GIT_CREDENTIAL_TOKEN is unset!"
    (( GIT_ERROR+=1 ))
  fi

  if [[ -z "$DUCT_GIT_CREDENTIAL_SERVER" ]]
  then
    __duct_msg e "DUCT_GIT_CREDENTIAL_SERVER is unset!"
    (( GIT_ERROR+=1 ))
  else
    __duct_urlinfo "$DUCT_GIT_CREDENTIAL_SERVER"

    if [[ "${DUCT_URLINFO["scheme"]}" != "https" ]]
    then
      __duct_msg e "only a https server is supported: $DUCT_GIT_CREDENTIAL_SERVER"
      (( GIT_ERROR+=1 ))
    fi
  fi

  if [[ $GIT_ERROR -gt 0 ]]
  then
    return 1
  fi

  local _CREDENTIAL_HELPER
  _CREDENTIAL_HELPER="$( git config --get credential.helper || : )"

  if [[ -z "$_CREDENTIAL_HELPER" ]]
  then
    __duct_msg d "no current credential helper"
  else
    __duct_msg d "current credential helper: $_CREDENTIAL_HELPER"
  fi

  if [[ "$_CREDENTIAL_HELPER" != "store" ]]
  then
    __duct_msg n "setting credential helper: '$_CREDENTIAL_HELPER' to 'store'"
    GIT_CONFIG="$DUCT_GIT_CONFIG_FILE" \
    __duct_run git config credential.helper "store"
  fi

  local _GIT_TOKEN
  _GIT_TOKEN="$( __duct_debase64 "$DUCT_GIT_CREDENTIAL_TOKEN" )"

  local _GIT_AUTH="${DUCT_URLINFO["scheme"]}://${DUCT_GIT_CREDENTIAL_USER}:${_GIT_TOKEN}@${DUCT_URLINFO["host"]}"

  DUCT_SFILE_OVERWRITE=true \
  DUCT_SFILE_FILEMODE=0600 \
  __duct_sfile "$GIT_CREDENTIAL_FILE" "$_GIT_AUTH"
}

# git fetch

# Options for git fetch command (defaults).
declare -a -r _DUCT_GIT_FETCH_OPTIONS=(
  --all
  --prune
  --quiet
)

# Path to fetch in (inherit `DUCT_GIT_WORKDIR`).
declare -g DUCT_GIT_FETCH_PATH="${DUCT_GIT_FETCH_PATH:-$DUCT_GIT_WORKDIR}"

# Options for git fetch command.
declare -g -a DUCT_GIT_FETCH_OPTIONS=( "${DUCT_GIT_FETCH_OPTIONS[@]:-${_DUCT_GIT_FETCH_OPTIONS[@]}}" )

# deps: duct-msg duct-run
# intl: false
# life: core
# desc: Run git fetch on a repository.
# opts:
__duct_git_fetch() {

  if [[ -d "${DUCT_GIT_FETCH_PATH}/.git" ]]
  then
    __duct_msg n "$DUCT_GIT_FETCH_PATH"
    __duct_run git -C "$DUCT_GIT_FETCH_PATH" fetch "${DUCT_GIT_FETCH_OPTIONS[@]}"
  else
    __duct_msg e "'$DUCT_GIT_FETCH_PATH' not a git repository!"
    return 1
  fi
}

# git checkout

# Options for git checkout command (defaults).
declare -a -r _DUCT_GIT_CHECKOUT_OPTIONS=(
  --quiet
)

# Options for git checkout command.
declare -g -a DUCT_GIT_CHECKOUT_OPTIONS=( "${DUCT_GIT_CHECKOUT_OPTIONS[@]:-${_DUCT_GIT_CHECKOUT_OPTIONS[@]}}" )

# Path to checkout in (inherit `DUCT_GIT_WORKDIR`).
declare -g DUCT_GIT_CHECKOUT_PATH="${DUCT_GIT_CHECKOUT_PATH:-$DUCT_GIT_WORKDIR}"

# Run git fetch before checkout.
declare -g DUCT_GIT_CHECKOUT_FETCH="${DUCT_GIT_CHECKOUT_FETCH:-true}"

# Git branch, commit or tag to checkout.
declare -g DUCT_GIT_CHECKOUT_BRANCH="${DUCT_GIT_CHECKOUT_BRANCH:-$DUCT_GIT_BRANCH}"

# deps: duct-msg duct-run
# intl: false
# life: core
# desc: Run git checkout on a specified branch or tag.
# opts:
__duct_git_checkout() {
  local -a GIT_OPTS=()
  local GIT_LOCAL_HEAD

  if [[ -d "${DUCT_GIT_CHECKOUT_PATH}/.git" ]]
  then

    if [[ "$DUCT_GIT_CHECKOUT_FETCH" == true ]]
    then
      DUCT_GIT_FETCH_PATH="$DUCT_GIT_CHECKOUT_PATH" \
      __duct_git_fetch
    fi

    GIT_LOCAL_HEAD="$( DUCT_GIT_LOCAL_HEAD_PATH="$DUCT_GIT_CHECKOUT_PATH" __duct_git_local_head )"

    if [[ "$DUCT_GIT_CHECKOUT_BRANCH" == "$GIT_LOCAL_HEAD" ]]
    then
      __duct_msg n "$DUCT_GIT_CHECKOUT_PATH at $DUCT_GIT_CHECKOUT_BRANCH"
      return 0
    fi

    DUCT_GIT_REMOTE_BRANCH_PATH="$DUCT_GIT_CHECKOUT_PATH"\
    __duct_git_remote_branch

    DUCT_GIT_LOCAL_BRANCH_PATH="$DUCT_GIT_CHECKOUT_PATH" \
    __duct_git_local_branch

    if [[ ! "${DUCT_GIT_REMOTE_BRANCH_LIST[*]}" =~ $DUCT_GIT_CHECKOUT_BRANCH ]] #&& [[ ! "${DUCT_GIT_LOCAL_BRANCH_LIST[*]}" =~ $DUCT_GIT_CHECKOUT_BRANCH ]]
    then
      GIT_OPTS+=( -B )
    fi

    __duct_msg n "$DUCT_GIT_CHECKOUT_BRANCH"
    __duct_run git -C "$DUCT_GIT_CHECKOUT_PATH" checkout "${DUCT_GIT_CHECKOUT_OPTIONS[@]}" "${GIT_OPTS[@]}" "$DUCT_GIT_CHECKOUT_BRANCH"

  else
    __duct_msg e "'$DUCT_GIT_CHECKOUT_PATH' not a git repository!"
    return 1
  fi
}

# git clone

# Options for `git clone` (defaults).
declare -a -r _DUCT_GIT_CLONE_OPTIONS=(
  --progress
)

# Options for `git clone`.
declare -g -a DUCT_GIT_CLONE_OPTIONS=( "${DUCT_GIT_CLONE_OPTIONS[@]:-${_DUCT_GIT_CLONE_OPTIONS[@]}}" )

# Path to clone in (inherit `DUCT_GIT_WORKDIR`).
declare -g DUCT_GIT_CLONE_PATH="${DUCT_GIT_CLONE_PATH:-$DUCT_GIT_WORKDIR}"

# Branch name to clone.
declare -g DUCT_GIT_CLONE_BRANCH="${DUCT_GIT_CLONE_BRANCH:-}"

# Remote name to clone (inherit DUCT_GIT_REMOTE).
declare -g DUCT_GIT_CLONE_REMOTE="${DUCT_GIT_CLONE_REMOTE:-$DUCT_GIT_REMOTE}"

# Enable/disable git pull if repository exists.
declare -g DUCT_GIT_CLONE_PULL="${DUCT_GIT_CLONE_PULL:-true}"

# Enable/disable git pull all.
declare -g DUCT_GIT_CLONE_PULL_ALL="${DUCT_GIT_CLONE_PULL_ALL:-false}"

# URL to clone from.
declare -g DUCT_GIT_CLONE_URL="${DUCT_GIT_CLONE_URL:-}"

# Path to clone, or pull from (with optional prefix).
declare -g DUCT_GIT_CLONE_PATH="${DUCT_GIT_CLONE_PATH:-}"

# Name of tag, commit or branch to checkout after clone.
declare -g DUCT_GIT_CLONE_CHECKOUT="${DUCT_GIT_CLONE_CHECKOUT:-}"

# deps: duct-msg duct-run
# intl: false
# life: core
# desc: Clone a git repository with optional pull.
# opts:
__duct_git_clone() {
  local -a GIT_OPTS=()
  local GIT_RC=0

  if [[ -z "$DUCT_GIT_CLONE_URL" ]]
  then
    __duct_msg e "no git url!"
    return 1
  fi

  # remote
  if [[ -n "$DUCT_GIT_CLONE_REMOTE" ]]
  then
    GIT_OPTS+=(
      --origin "$DUCT_GIT_CLONE_REMOTE"
    )
  fi

  # branch
  if [[ -n "$DUCT_GIT_CLONE_BRANCH" ]]
  then
    GIT_OPTS+=(
      --branch "$DUCT_GIT_CLONE_BRANCH"
    )
  fi

  if [[ ! -d "${DUCT_GIT_CLONE_PATH}/.git" ]]
  then
    __duct_msg n "'$DUCT_GIT_CLONE_URL' to '$DUCT_GIT_CLONE_PATH'"
    __duct_run git clone "${DUCT_GIT_CLONE_OPTIONS[@]}" "${GIT_OPTS[@]}" "$DUCT_GIT_CLONE_URL" "$DUCT_GIT_CLONE_PATH" || GIT_RC=$?

    if [[ "$GIT_RC" -gt 0 ]]
    then
      return $GIT_RC
    fi

    if [[ -n "$DUCT_GIT_CLONE_CHECKOUT" ]]
    then
      DUCT_GIT_CHECKOUT_BRANCH="$DUCT_GIT_CLONE_CHECKOUT" \
      DUCT_GIT_CHECKOUT_FETCH=false \
      DUCT_GIT_CHECKOUT_PATH="$DUCT_GIT_CLONE_PATH" \
      __duct_git_checkout
      return
    fi
  else
    if [[ "$DUCT_GIT_CLONE_PULL" == true ]]
    then
      DUCT_GIT_PULL_ALL="$DUCT_GIT_CLONE_PULL_ALL" \
      DUCT_GIT_PULL_BRANCH="$DUCT_GIT_CLONE_BRANCH" \
      DUCT_GIT_PULL_CHECKOUT="$DUCT_GIT_CLONE_CHECKOUT" \
      DUCT_GIT_PULL_PATH="$DUCT_GIT_CLONE_PATH" \
      DUCT_GIT_PULL_REMOTE="$DUCT_GIT_CLONE_REMOTE" \
      __duct_git_pull
      return
    fi
  fi
}

# git pull

# Options for `git pull` (defaults).
declare -g -a -r _DUCT_GIT_PULL_OPTIONS=(
  --progress
  --prune
  --tags
)

# Options for `git gc` (defaults).
declare -g -a -r _DUCT_GIT_PULL_GC_OPTIONS=(
  --auto
)

# Options for `git pull`.
declare -g -a DUCT_GIT_PULL_OPTIONS=( "${DUCT_GIT_PULL_OPTIONS[@]:-${_DUCT_GIT_PULL_OPTIONS[@]}}" )

# Path to pull in (inherit `DUCT_GIT_WORKDIR`)
declare -g DUCT_GIT_PULL_PATH="${DUCT_GIT_PULL_PATH:-$DUCT_GIT_WORKDIR}"

# Remote name to pull (inherit DUCT_GIT_REMOTE).
declare -g DUCT_GIT_PULL_REMOTE="${DUCT_GIT_PULL_REMOTE:-$DUCT_GIT_REMOTE}"

# Branch name to pull.
declare -g DUCT_GIT_PULL_BRANCH="${DUCT_GIT_PULL_BRANCH:-}"

# Name of tag, commit or branch to checkout after clone.
declare -g DUCT_GIT_PULL_CHECKOUT="${DUCT_GIT_PULL_CHECKOUT:-}"

# Enable/disable pull all branches.
declare -g DUCT_GIT_PULL_ALL="${DUCT_GIT_PULL_ALL:-false}"

# Enable/disable pull gc run.
declare -g DUCT_GIT_PULL_GC="${DUCT_GIT_PULL_GC:-false}"

# Options for `git gc`.
declare -g -a DUCT_GIT_PULL_GC_OPTIONS=( "${DUCT_GIT_PULL_GC_OPTIONS[@]:-${_DUCT_GIT_PULL_GC_OPTIONS[@]}}" )

# deps: duct-msg duct-run
# intl: false
# life: core
# desc: Pull a git repository.
# opts:
__duct_git_pull() {
  local GIT_BRANCH="$DUCT_GIT_PULL_BRANCH"
  local GIT_CHECKOUT="$DUCT_GIT_PULL_CHECKOUT"

  if [[ -d "${DUCT_GIT_PULL_PATH}/.git" ]]
  then

    if [[ -z "$GIT_BRANCH" ]]
    then
      GIT_BRANCH="$(
        DUCT_GIT_REMOTE_HEAD_PATH="$DUCT_GIT_PULL_PATH" \
        DUCT_GIT_REMOTE_HEAD_REMOTE="$DUCT_GIT_PULL_REMOTE" \
        __duct_git_remote_head
      )"

      if [[ -z "$GIT_BRANCH" ]]
      then
        __duct_msg w "'$DUCT_GIT_PULL_PATH' nothing to pull!"
        return
      fi
    fi

    if [[ -z "$GIT_CHECKOUT" ]]
    then
      GIT_CHECKOUT="$GIT_BRANCH"
    fi

    if [[ -n "$GIT_CHECKOUT" ]]
    then
      DUCT_GIT_CHECKOUT_BRANCH="$GIT_CHECKOUT" \
      DUCT_GIT_CHECKOUT_FETCH=false \
      DUCT_GIT_CHECKOUT_PATH="$DUCT_GIT_PULL_PATH" \
      __duct_git_checkout
    fi

    __duct_msg n "$DUCT_GIT_PULL_PATH"

    if [[ "$DUCT_GIT_PULL_ALL" == true ]]
    then
      __duct_run git -C "$DUCT_GIT_PULL_PATH" pull "${DUCT_GIT_PULL_OPTIONS[@]}" "$DUCT_GIT_PULL_REMOTE"
    else
      __duct_run git -C "$DUCT_GIT_PULL_PATH" pull "${DUCT_GIT_PULL_OPTIONS[@]}" "$DUCT_GIT_PULL_REMOTE" "$GIT_BRANCH"
    fi

    if [[ "$DUCT_GIT_PULL_GC" == true ]]
    then
      __duct_run git -C "$DUCT_GIT_PULL_PATH" gc "${DUCT_GIT_PULL_GC_OPTIONS[@]}"
    fi
  else
    __duct_msg e "'$DUCT_GIT_PULL_PATH' not a git repository!"
  fi
}

# git commit

# Options for `git commit` (defaults).
declare -a -r _DUCT_GIT_COMMIT_OPTIONS=(
  --verbose
)

# File(s) to add and commit.
declare -a -r _DUCT_GIT_COMMIT_LIST=()

# Path to commit in (inherit `DUCT_GIT_WORKDIR`).
declare -g DUCT_GIT_COMMIT_PATH="${DUCT_GIT_COMMIT_PATH:-$DUCT_GIT_WORKDIR}"

# Options for `git commit`.
declare -g -a DUCT_GIT_COMMIT_OPTIONS=( "${DUCT_GIT_COMMIT_OPTIONS[@]:-${_DUCT_GIT_COMMIT_OPTIONS[@]}}" )

# Enable/disable Signed-off-by
declare -g DUCT_GIT_COMMIT_SIGNOFF="${DUCT_GIT_COMMIT_SIGNOFF:-false}"

# Enable/disable GPG signing of commit.
declare -g DUCT_GIT_COMMIT_GPG_SIGN="${DUCT_GIT_COMMIT_GPG_SIGN:-false}"

# Branch name to commit to, will be created if not exists (inherit `DUCT_GIT_BRANCH`).
declare -g DUCT_GIT_COMMIT_BRANCH="${DUCT_GIT_COMMIT_BRANCH:-$DUCT_GIT_BRANCH}"

# Reuse branch if it exists.
declare -g DUCT_GIT_COMMIT_BRANCH_REUSE="${DUCT_GIT_COMMIT_BRANCH_REUSE:-true}"

# Remote name to push (inherit `DUCT_GIT_REMOTE`).
declare -g DUCT_GIT_COMMIT_REMOTE="${DUCT_GIT_COMMIT_REMOTE:-$DUCT_GIT_REMOTE}"

# Enable/disable `git push`.
declare -g DUCT_GIT_COMMIT_PUSH="${DUCT_GIT_COMMIT_PUSH:-false}"

# Message to commit with.
declare -g DUCT_GIT_COMMIT_MESSAGE="${DUCT_GIT_COMMIT_MESSAGE:-}"

# Allow empty commits.
declare -g DUCT_GIT_COMMIT_EMPTY="${DUCT_GIT_COMMIT_EMPTY:-false}"

# shellcheck disable=SC2206
# File(s) to add and commit.
declare -g -a DUCT_GIT_COMMIT_LIST=( ${DUCT_GIT_COMMIT_LIST[@]:-${_DUCT_GIT_COMMIT_LIST[@]}} )

# Set to true if commit has changes.
declare -g -x DUCT_GIT_COMMIT_CHANGE=false

# deps: duct-msg duct-run
# intl: false
# life: core
# desc: Commit to a git repository with optional push.
# opts:
__duct_git_commit() {
  local -a GIT_OPTS=()
  local -a GIT_STATUS=()
  local GIT_COMMIT=0
  local GIT_ERROR=0

  if [[ -z "$DUCT_GIT_COMMIT_MESSAGE" ]]
  then
    __duct_msg e "no commit message!"
    (( GIT_ERROR+=1 ))
  fi

  if [[ "${#DUCT_GIT_COMMIT_LIST[@]}" -lt 1 ]]
  then
    __duct_msg e "nothing to commit!"
    (( GIT_ERROR+=1 ))
  fi

  if [[ "$GIT_ERROR" -gt 0 ]]
  then
    return 1
  fi

  if [[ "$DUCT_GIT_COMMIT_SIGNOFF" == true ]]
  then
    GIT_OPTS+=( --signoff )
  fi

  if [[ "$DUCT_GIT_COMMIT_GPG_SIGN" == true ]]
  then
    GIT_OPTS+=( --gpg-sign )
  fi

  DUCT_GIT_CHECKOUT_PATH=$DUCT_GIT_COMMIT_PATH \
  DUCT_GIT_CHECKOUT_BRANCH=$DUCT_GIT_COMMIT_BRANCH \
  __duct_git_checkout

  __duct_msg n "add '${DUCT_GIT_COMMIT_LIST[*]}'"
  __duct_run git -C "$DUCT_GIT_COMMIT_PATH" add "${DUCT_GIT_COMMIT_LIST[@]}"

  # check changes
  readarray -t GIT_STATUS < <( __duct_run git -C "$DUCT_GIT_COMMIT_PATH" status --porcelain=v1 )

  for _STATUS in "${GIT_STATUS[@]}"
  do
    for _FILE in "${DUCT_GIT_COMMIT_LIST[@]}"
    do
      if [[ "${_STATUS##* }" =~ ^($_FILE) ]]
      then
        __duct_msg d "change: ${_STATUS##* }"
        (( GIT_COMMIT+=1 ))
      fi
    done
  done

  # allow empty
  if [[ "$DUCT_GIT_COMMIT_EMPTY" == true ]] && [[ "$GIT_COMMIT" -eq 0 ]]
  then
    GIT_OPTS+=( --allow-empty )
    (( GIT_COMMIT+=1 ))
  fi

  if [[ "$GIT_COMMIT" -ge 1 ]]
  then
    __duct_msg n "'$DUCT_GIT_COMMIT_MESSAGE' '${DUCT_GIT_COMMIT_LIST[*]}'"
    __duct_run git -C "$DUCT_GIT_COMMIT_PATH" commit "${DUCT_GIT_COMMIT_OPTIONS[@]}" "${GIT_OPTS[@]}" --message="$DUCT_GIT_COMMIT_MESSAGE" "${DUCT_GIT_COMMIT_LIST[@]}"

    if [[ "$DUCT_GIT_COMMIT_PUSH" == true ]]
    then
      __duct_msg n "push $DUCT_GIT_COMMIT_REMOTE $DUCT_GIT_COMMIT_BRANCH"
      __duct_run git -C "$DUCT_GIT_COMMIT_PATH" push --set-upstream "$DUCT_GIT_COMMIT_REMOTE" "$DUCT_GIT_COMMIT_BRANCH"
    fi

    DUCT_GIT_COMMIT_CHANGE=true
  else
    __duct_msg n "nothing to commit"
  fi
}

# git tag

# Path to tag (inherit `DUCT_GIT_WORKDIR`).
declare -g DUCT_GIT_TAG_PATH="${DUCT_GIT_TAG_PATH:-$DUCT_GIT_WORKDIR}"

# The tag name.
declare -g DUCT_GIT_TAG_NAME="${DUCT_GIT_TAG_NAME:-}"

# Commit hash to use for tag.
declare -g DUCT_GIT_TAG_COMMIT="${DUCT_GIT_TAG_COMMIT:-}"

# Tag message (annoted or signed).
declare -g DUCT_GIT_TAG_MESSAGE="${DUCT_GIT_TAG_MESSAGE:-}"

# Annotate the tag (requires `DUCT_GIT_TAG_MESSAGE`).
declare -g DUCT_GIT_TAG_ANNOTATE="${DUCT_GIT_TAG_ANNOTATE:-false}"

# Sign the tag (requires `DUCT_GIT_TAG_MESSAGE`).
declare -g DUCT_GIT_TAG_SIGN="${DUCT_GIT_TAG_SIGN:-false}"

# Push tag.
declare -g DUCT_GIT_TAG_PUSH="${DUCT_GIT_TAG_PUSH:-true}"

# deps: duct-msg duct-run
# intl: false
# life: core
# desc: Create a git tag.
# opts: <tagname>
__duct_git_tag() {
  local GIT_TAG="${1:-$DUCT_GIT_TAG_NAME}"

  local -a GIT_OPTS=()
  local GIT_ERROR=0

  if [[ "$DUCT_GIT_TAG_SIGN" == true ]]
  then
    GIT_OPTS=(
      --sign
      --message="$DUCT_GIT_TAG_MESSAGE"
    )

  elif [[ "$DUCT_GIT_TAG_ANNOTATE" == true ]]
  then
    GIT_OPTS=(
      --annotate
      --message="$DUCT_GIT_TAG_MESSAGE"
    )
  fi

  if [[ "${#GIT_OPTS[@]}" -ge 1 ]] && [[ -z "$DUCT_GIT_TAG_MESSAGE" ]]
  then
    __duct_msg e "no message!"
    (( GIT_ERROR+=1 ))
  fi

  if [[ -z "$GIT_TAG" ]]
  then
    __duct_msg e "no tagname!"
    (( GIT_ERROR+=1 ))
  fi

  if [[ "$GIT_ERROR" -gt 0 ]]
  then
    return 1
  fi

  __duct_run git -C "$DUCT_GIT_TAG_PATH" tag "${GIT_OPTS[@]}" "$GIT_TAG"
}

# git tag list

# Path to list tag from (inherit `DUCT_GIT_WORKDIR`).
declare -g DUCT_GIT_TAG_LIST_PATH="${DUCT_GIT_TAG_LIST_PATH:-$DUCT_GIT_WORKDIR}"

# Tag to list (`all` or `latest`).
declare -g DUCT_GIT_TAG_LIST_SEARCH="${DUCT_GIT_TAG_LIST_SEARCH:-"all"}"

# List ('all') annotation or commit message (git tag -n#).
declare -g -i DUCT_GIT_TAG_LIST_ANNOTATION="${DUCT_GIT_TAG_LIST_ANNOTATION:-0}"

# Regex match of a tag.
declare -g DUCT_GIT_TAG_LIST_MATCH="${DUCT_GIT_TAG_LIST_MATCH:-"^((v)?[0-9.]+)"}"

# deps: duct-msg duct-run
# intl: false
# life: core
# desc: List git tags (latest or all).
# opts:
__duct_git_tag_list() {
  local -a GIT_TAG_LIST
  local -a GIT_OPTS=()

  if [[ "$DUCT_GIT_TAG_LIST_ANNOTATION" -ge 1 ]]
  then
    GIT_OPTS=( --format="%(refname:lstrip=2) %(contents:lines=$DUCT_GIT_TAG_LIST_ANNOTATION)" )
  else
    GIT_OPTS=( --format="%(refname:lstrip=2)" )
  fi

  if [[ "$DUCT_GIT_TAG_LIST_SEARCH" == "latest" ]]
  then
    readarray -t -n 0 GIT_TAG_LIST < <( __duct_run git -C "$DUCT_GIT_TAG_LIST_PATH" describe --tags --abbrev --always )

    if [[ "${#GIT_TAG_LIST[@]}" -eq 1 ]]
    then
      if [[ "${GIT_TAG_LIST[0]}" =~ ^([a-f0-9]+)$ ]]
      then
        __duct_msg w "no latest tag found!"

      elif [[ "${GIT_TAG_LIST[0]}" =~ $DUCT_GIT_TAG_LIST_MATCH ]]
      then
        printf "%b\n" "${GIT_TAG_LIST[0]}"
      fi
    else
      __duct_msg e "no tag or commit yet!"
    fi

  elif [[ "$DUCT_GIT_TAG_LIST_SEARCH" == "all" ]]
  then
    readarray -t -n 0 GIT_TAG_LIST < <( __duct_run git -C "$DUCT_GIT_TAG_LIST_PATH" tag --list "${GIT_OPTS[@]}" )

    if [[ "${#GIT_TAG_LIST[@]}" -ge 1 ]]
    then
      printf "%b\n" "${GIT_TAG_LIST[@]}"
    else
      __duct_msg w "no tag found!"
    fi
  fi
}

# git strip remote

# deps: duct-msg duct-run
# intl: false
# life: core
# desc: Strip username and token from a git HTTPS remote URL (uses `DUCT_GIT_REMOTE`).
# opts:
__duct_git_strip_remote() {
  local GIT_REMOTE

  if [[ ! -d .git ]]
  then
    __duct_msg e "not a git repository!"
    exit 1
  fi

  GIT_REMOTE=$( git remote get-url --push "$DUCT_GIT_REMOTE" )

  if [[ ! "$GIT_REMOTE" =~ https:// ]]
  then
    __duct_msg w "not a https remote url, skipping!"
    return 0
  fi

  GIT_REMOTE="$( __duct_gnu_sed -e "s?\(https://\)\(.*\)@\(.*\)?\1\3?g" <<< "$GIT_REMOTE" )"

  __duct_msg n "setting remote $DUCT_GIT_REMOTE to $GIT_REMOTE"
  __duct_run git remote set-url "$DUCT_GIT_REMOTE" "$GIT_REMOTE"
}

# git cvc check

# Allowed conventional commits types (defaults).
declare -r -a _DUCT_GIT_CVC_CHECK_TYPES=(
  "build"
  "chore"
  "ci"
  "docs"
  "feat"
  "fix"
  "import"
  "merge"
  "perf"
  "refactor"
  "revert"
  "style"
  "test"
  "todo"
)

# Allowed conventional commits scope (defaults).
declare -r -a _DUCT_GIT_CVC_CHECK_SCOPE=(
  ".*"
)

# Allowed conventional commits description (defaults).
declare -r -a _DUCT_GIT_CVC_CHECK_DESC=(
  "[:space:]"
  "[:digit:]"
  "[:lower:]"
  "[:punct:]"
)

# Path to check conventional commits.
declare -g DUCT_GIT_CVC_CHECK_PATH="${DUCT_GIT_CVC_CHECK_PATH:-$PWD}"

# Allowed conventional commits types.
declare -g -a DUCT_GIT_CVC_CHECK_TYPES=( "${DUCT_GIT_CVC_CHECK_TYPES[@]:-${_DUCT_GIT_CVC_CHECK_TYPES[@]}}" )

# Allowed conventional commits scope.
declare -g -a DUCT_GIT_CVC_CHECK_SCOPE=( "${DUCT_GIT_CVC_CHECK_SCOPE[@]:-${_DUCT_GIT_CVC_CHECK_SCOPE[@]}}" )

# Allowed conventional commits description.
declare -g -a DUCT_GIT_CVC_CHECK_DESC=( "${DUCT_GIT_CVC_CHECK_DESC[@]:-${_DUCT_GIT_CVC_CHECK_DESC[@]}}" )

# Minimal length of conventional commits description.
declare -g -i DUCT_GIT_CVC_CHECK_MIN="${DUCT_GIT_CVC_CHECK_MIN:-5}"

# Maximal length of conventional commits description.
declare -g -i DUCT_GIT_CVC_CHECK_MAX="${DUCT_GIT_CVC_CHECK_MAX:-75}"

# Show passed conventional commits.
declare -g DUCT_GIT_CVC_CHECK_PASS="${DUCT_GIT_CVC_CHECK_PASS:-false}"

# Show failed conventional commits.
declare -g DUCT_GIT_CVC_CHECK_FAIL="${DUCT_GIT_CVC_CHECK_FAIL:-true}"

# Commit(s) to check (default all).
declare -g DUCT_GIT_CVC_CHECK_COMMIT="${DUCT_GIT_CVC_CHECK_COMMIT:-}"

# deps: duct-msg duct-run
# intl: false
# life: test
# desc: Check git conventional commits (<https://www.conventionalcommits.org/>).
# opts:
__duct_git_cvc_check() {
  local -a GIT_DESC
  local -a GIT_FAIL=()
  local -a GIT_LOG
  local -a GIT_PASS=()
  local -a GIT_SCOPE
  local -a GIT_TYPES
  local GIT_COMMIT
  local GIT_MATCH

  local _GIT_AUTHOR
  local _GIT_BREAK
  local _GIT_DESC
  local _GIT_FAIL
  local _GIT_HASH
  local _GIT_PASS
  local _GIT_SCOPE
  local _GIT_TYPE

  if [[ ! -d "${DUCT_GIT_CVC_CHECK_PATH}/.git" ]]
  then
    __duct_msg e "not a git repository!"
    return 1
  fi

  # join matches
  local IFS
  IFS="|" GIT_TYPES=( "${DUCT_GIT_CVC_CHECK_TYPES[*]}" )
  IFS="" GIT_SCOPE=( "${DUCT_GIT_CVC_CHECK_SCOPE[*]}" )
  IFS="" GIT_DESC=( "${DUCT_GIT_CVC_CHECK_DESC[*]}" )
  GIT_MATCH="^(([0-9a-f]+) (${GIT_TYPES[*]})(\(${GIT_SCOPE[*]}\))?(!)?: ([${GIT_DESC[*]}]{${DUCT_GIT_CVC_CHECK_MIN},${DUCT_GIT_CVC_CHECK_MAX}})$)"
  unset IFS

  if [[ -n "$DUCT_GIT_CVC_CHECK_COMMIT" ]]
  then
    readarray -t -n 0 GIT_LOG < <( __duct_run git -C "$DUCT_GIT_CVC_CHECK_PATH" log --pretty='format:%H %s' "$DUCT_GIT_CVC_CHECK_COMMIT" )
  else
    readarray -t -n 0 GIT_LOG < <( __duct_run git -C "$DUCT_GIT_CVC_CHECK_PATH" log --pretty='format:%H %s' )
  fi

  for GIT_COMMIT in "${GIT_LOG[@]}"
  do
    if [[ "$GIT_COMMIT" =~ $GIT_MATCH ]]
    then
      if [[ "$DUCT_GIT_CVC_CHECK_PASS" == true ]]
      then
        _GIT_HASH="${BASH_REMATCH[2]}"
        _GIT_TYPE="${BASH_REMATCH[3]}"
        _GIT_SCOPE="${BASH_REMATCH[4]}"
        _GIT_BREAK="${BASH_REMATCH[5]}"
        _GIT_DESC="${BASH_REMATCH[6]}"
        _GIT_AUTHOR=$( __duct_run git -C "$DUCT_GIT_CVC_CHECK_PATH" log --pretty='format:%aN <%aE>' "${_GIT_HASH}^!" )

        # TODO: check file
        #readarray -t -n 0 _GIT_FILES < <( __duct_run git -C "$DUCT_GIT_CVC_CHECK_PATH" log --name-only --pretty='format:' "${_GIT_HASH}^!" )
        #__duct_msg d "PASS: ${_GIT_FILES[*]}"
        # TODO: check desc

        GIT_PASS+=( "${GIT_COMMIT//${_GIT_HASH} } ($_GIT_AUTHOR) [$_GIT_HASH]" )
      fi
    elif [[ "$GIT_COMMIT" =~ ^(([0-9a-f]+) (.*)$) ]]
    then
      if [[ "$DUCT_GIT_CVC_CHECK_FAIL" == true ]]
      then
        _GIT_HASH="${BASH_REMATCH[2]}"
        _GIT_AUTHOR=$( __duct_run git -C "$DUCT_GIT_CVC_CHECK_PATH" log --pretty='format:%aN <%aE>' "${_GIT_HASH}^!" )

        GIT_FAIL+=( "${GIT_COMMIT//${_GIT_HASH} } ($_GIT_AUTHOR) [$_GIT_HASH]" )
      fi
    else
      __duct_msg e "WTF?!"
      return 1
    fi
  done

  if [[ "$DUCT_GIT_CVC_CHECK_PASS" == true ]]
  then
    for _GIT_PASS in "${GIT_PASS[@]}"
    do
      __duct_msg n "PASS: $_GIT_PASS"
    done
  fi

  if [[ "$DUCT_GIT_CVC_CHECK_FAIL"  == true ]]
  then
    for _GIT_FAIL in "${GIT_FAIL[@]}"
    do
      __duct_msg e "FAIL: $_GIT_FAIL"
    done
    if [[ "${#GIT_FAIL[@]}" -gt 0 ]]
    then
      return 1
    fi
  fi
}

# git refs cleanup

# ...
declare -g DUCT_GIT_REFS_CLEANUP_PATH="${DUCT_GIT_REFS_CLEANUP_PATH:-$DUCT_GIT_WORKDIR}"

# ...
declare -g DUCT_GIT_REFS_CLEANUP_ASK="${DUCT_GIT_REFS_CLEANUP_ASK:-true}"

# ...
declare -g -i DUCT_GIT_REFS_CLEANUP_TIMEOUT="${DUCT_GIT_REFS_CLEANUP_TIMEOUT:-30}"

# deps: duct-msg duct-run
# intl: false
# life: core
# desc: Cleanup git refs/branches not found on remote (uses `DUCT_GIT_REMOTE`).
# opts: [git-path]
__duct_git_refs_cleanup() {
  local GIT_PATH="${1:-$DUCT_GIT_REFS_CLEANUP_PATH}"

  local -a GIT_REFS_ALL=()
  local -a GIT_REFS_HEADS=()
  local -a GIT_REFS_OTHERS=()
  local -a GIT_REFS_REMOTES=()
  local -a GIT_REFS_TAGS=()
  local GIT_CURRENT
  local GIT_DELETE
  local GIT_REF
  local GIT_REFS_MATCH

  GIT_CURRENT="$( __duct_run git -C "$GIT_PATH" branch --show-current )"

  readarray -t GIT_REFS_ALL < <( __duct_run git -C "$GIT_PATH" for-each-ref --format='%(refname)' )

  for GIT_REF in "${GIT_REFS_ALL[@]}"
  do
    if [[ "$GIT_REF" =~ ^(refs/heads/(.*)) ]]
    then
      GIT_REFS_HEADS+=( "${BASH_REMATCH[-1]}" )

    elif [[ "$GIT_REF" =~ ^(refs/remotes/$DUCT_GIT_REMOTE/(.*)) ]]
    then
      _GIT_REF="${BASH_REMATCH[-1]}"

      # skip remotes HEAD
      if [[ "$_GIT_REF" !=  "HEAD" ]]
      then
        GIT_REFS_REMOTES+=( "$_GIT_REF" )
      fi

    elif [[ "$GIT_REF" =~ ^(refs/tags/(.*)) ]]
    then
      GIT_REFS_TAGS+=( "${BASH_REMATCH[-1]}" )
    else
      GIT_REFS_OTHERS+=( "$GIT_REF" )
    fi
  done

  # heads
  if [[ "${#GIT_REFS_HEADS[@]}" -gt 0 ]]
  then
    __duct_msg n "heads: ${GIT_REFS_HEADS[*]}"
  fi

  # remotes
  if [[ "${#GIT_REFS_REMOTES[@]}" -gt 0 ]]
  then
    __duct_msg n "remotes: ${GIT_REFS_REMOTES[*]}"
  fi

  # tags
  if [[ "${#GIT_REFS_TAGS[@]}" -gt 0 ]]
  then
    __duct_msg n "tags: ${GIT_REFS_TAGS[*]}"
  fi

  # others
  if [[ "${#GIT_REFS_OTHERS[@]}" -gt 0 ]]
  then
    __duct_msg w "others: ${GIT_REFS_OTHERS[*]}"
  fi

  IFS="|" GIT_REFS_MATCH="${GIT_REFS_REMOTES[*]}"
  unset IFS

  for GIT_REF in "${GIT_REFS_HEADS[@]}"
  do
    if [[ ! "$GIT_REF" =~ ($GIT_REFS_MATCH) ]]
    then

      if [[ "$GIT_CURRENT" == "$GIT_REF" ]]
      then
        __duct_msg w "you are working on $GIT_CURRENT, not yet on remote $DUCT_GIT_REMOTE"
        continue
      fi

      __duct_msg w "$GIT_PATH ref $GIT_REF not on remote $DUCT_GIT_REMOTE!"

      if [[ "$DUCT_GIT_REFS_CLEANUP_ASK" == true ]]
      then
        while true
        do
          read -r -t "$DUCT_GIT_REFS_CLEANUP_TIMEOUT" -p "DELETE $GIT_REF [yes/(NO)]: " GIT_DELETE || printf "\n"

          case "${GIT_DELETE:="no"}"
          in
            Y|YES|y|yes)
              __duct_run git -C "$GIT_PATH" branch --delete --force "$GIT_REF"
              break
            ;;
            N|NO|n|no)
              break
            ;;
          esac
        done
      else
        __duct_run git -C "$GIT_PATH" branch --delete --force "$GIT_REF"
      fi
    fi
  done
}

# git check

# Allowed conventional commit types (defaults).
declare -r -a _DUCT_GIT_CHECK_TYPE=(
  "build"
  "change"
  "chore"
  "ci"
  "deprecate"
  "docs"
  "feat"
  "fix"
  "import"
  "merge"
  "perf"
  "refactor"
  "remove"
  "revert"
  "security"
  "style"
  "test"
)

# Allowed conventional commit scope (defaults).
declare -r -a _DUCT_GIT_CHECK_SCOPE=(
  "[:digit:]"
  "[:lower:]"
  "[:punct:]"
  "[:space:]"
)

# Allowed conventional commit description (defaults).
declare -r -a _DUCT_GIT_CHECK_DESC=(
  "[:digit:]"
  "[:lower:]"
  "[:punct:]"
  "[:space:]"
)

# Path to check conventional commits.
declare -g DUCT_GIT_CHECK_PATH="${DUCT_GIT_CHECK_PATH:-$DUCT_GIT_WORKDIR}"

# Allowed conventional commit types.
declare -g -a DUCT_GIT_CHECK_TYPE=( "${DUCT_GIT_CHECK_TYPE[@]:-${_DUCT_GIT_CHECK_TYPE[@]}}" )

# Allowed conventional commit scope.
declare -g -a DUCT_GIT_CHECK_SCOPE=( "${DUCT_GIT_CHECK_SCOPE[@]:-${_DUCT_GIT_CHECK_SCOPE[@]}}" )

# Allowed conventional commit description.
declare -g -a DUCT_GIT_CHECK_DESC=( "${DUCT_GIT_CHECK_DESC[@]:-${_DUCT_GIT_CHECK_DESC[@]}}" )

# Minimal length of conventional commit scope.
declare -g -i DUCT_GIT_CHECK_SCOPE_MIN=${DUCT_GIT_CHECK_SCOPE_MIN:-5}

# Maximal length of conventional commit scope.
declare -g -i DUCT_GIT_CHECK_SCOPE_MAX=${DUCT_GIT_CHECK_SCOPE_MAX:-75}

# Minimal length of conventional commit description.
declare -g -i DUCT_GIT_CHECK_DESC_MIN=${DUCT_GIT_CHECK_DESC_MIN:-5}

# Maximal length of conventional commit description.
declare -g -i DUCT_GIT_CHECK_DESC_MAX=${DUCT_GIT_CHECK_DESC_MAX:-75}

# Check conventional commit body (TODO).
declare -g DUCT_GIT_CHECK_BODY="${DUCT_GIT_CHECK_BODY:-false}"

# Check signed commit (TODO).
declare -g DUCT_GIT_CHECK_SIGNED="${DUCT_GIT_CHECK_SIGNED:-false}"

# Show passed conventional commits.
declare -g DUCT_GIT_CHECK_PASS="${DUCT_GIT_CHECK_PASS:-false}"

# Show failed conventional commits.
declare -g DUCT_GIT_CHECK_FAIL="${DUCT_GIT_CHECK_FAIL:-true}"

# Commit(s) to check (default all).
declare -g DUCT_GIT_CHECK_COMMIT="${DUCT_GIT_CHECK_COMMIT:-}"

# deps: duct-array duct-msg duct-run
# intl: false
# life: test
# desc: Check git conventional commits (<https://www.conventionalcommits.org/>).
# opts: [commit]
__duct_git_check() {
  local GIT_COMMIT="${1:-$DUCT_GIT_CHECK_COMMIT}"

  local -A GIT_DATA
  local -a GIT_BODY
  local -a GIT_FAIL=()
  local -a GIT_FAIL_BODY=()
  local -a GIT_FAIL_SIGNED=()
  local -a GIT_FILE
  local -a GIT_LOG
  local -a GIT_PASS=()
  #local -a GIT_PASS_BODY=()
  #local -a GIT_PASS_SIGNED=()
  local -i GIT_RC=0

  # https://git-scm.com/docs/pretty-formats
  local GIT_LOG_MAIN="format:%H %s%n%at %an <%ae> %G?"
  local GIT_LOG_BODY="format:%b%-"

  if [[ ! -d "$DUCT_GIT_CHECK_PATH/.git" ]]
  then
    __duct_msg e "$DUCT_GIT_CHECK_PATH not git repository! ${DUCT_SCRIPT_FILE}:${BASH_LINENO[1]}"
    return 1
  fi

  if [[ -n "$GIT_COMMIT" ]]
  then
    readarray -t -n 0 GIT_LOG < <( __duct_run git -C "$DUCT_GIT_CHECK_PATH" log --name-status --pretty="$GIT_LOG_MAIN" "$GIT_COMMIT" )
  else
    readarray -t -n 0 GIT_LOG < <( __duct_run git -C "$DUCT_GIT_CHECK_PATH" log --name-status --pretty="$GIT_LOG_MAIN" )
  fi

  # add final newline (end of commit)
  GIT_LOG+=( "" )

  for VAL in "${GIT_LOG[@]}"
  do
    # commit hash + subject
    if [[ "$VAL" =~ ^(([0-9a-f]{40,64}) (.*)) ]]
    then
      GIT_DATA["hash"]="${BASH_REMATCH[2]}"
      GIT_DATA["subject"]="${BASH_REMATCH[3]}"

    # author date + author name + author email
    elif [[ "$VAL" =~ ^(([0-9]{1,11}) (.*) \<(.*)\> (G|B|U|X|Y|R|E|N))$ ]] # TODO: better regex
    then
      GIT_DATA["date"]="${BASH_REMATCH[2]}"
      GIT_DATA["author"]="${BASH_REMATCH[3]}"
      GIT_DATA["email"]="${BASH_REMATCH[4]}"
      GIT_DATA["signed"]="${BASH_REMATCH[5]}"

    # status + filename(s)
  elif [[ "$VAL" =~ ^((A|C[0-9]+|D|M([0-9]+)?|R[0-9]+|T|U|X|B)[[:space:]](.*)) ]] # TODO: better regex
    then
      GIT_FILE+=( "${BASH_REMATCH[4]}" )

    # end of commit & check
    elif [[ "$VAL" =~ ^()$ ]]
    then
      if [[ "$DUCT_GIT_CHECK_BODY" == true ]]
      then
        readarray -t -n 0 GIT_BODY < <( __duct_run git -C "$DUCT_GIT_CHECK_PATH" log --pretty="$GIT_LOG_BODY" "${GIT_DATA["hash"]}^!" )
      fi

      _GIT_INFO="${GIT_DATA["subject"]} (${GIT_DATA["author"]} <${GIT_DATA["email"]}> ${GIT_DATA["signed"]}) [${GIT_DATA["hash"]} ${GIT_FILE[*]}]"

      # join matches
      local IFS
      IFS="|" _GIT_TYPE="${DUCT_GIT_CHECK_TYPE[*]}"
      IFS=""  _GIT_SCOPE="${DUCT_GIT_CHECK_SCOPE[*]}"
      IFS=""  _GIT_DESC="${DUCT_GIT_CHECK_DESC[*]}"
      _GIT_MATCH=(
        "^((${_GIT_TYPE})(\([${_GIT_SCOPE}]{${DUCT_GIT_CHECK_SCOPE_MIN},${DUCT_GIT_CHECK_SCOPE_MAX}}\))?(!)?:"
        "([${_GIT_DESC}]{${DUCT_GIT_CHECK_DESC_MIN},${DUCT_GIT_CHECK_DESC_MAX}})$)"
      )
      unset IFS

      # check valid subject
      if [[ "${GIT_DATA["subject"]}" =~ ${_GIT_MATCH[*]} ]]
      then
        GIT_PASS+=( "SUBJECT PASS: $_GIT_INFO" )
      else
        GIT_FAIL+=( "SUBJECT FAIL: $_GIT_INFO" )
      fi

      # TODO: check valid body
      # TODO: check valid signed
      if [[ "$DUCT_GIT_CHECK_SIGNED" == true ]]
      then
        if [[ "${GIT_DATA["signed"]}" =~ ^(G)$ ]] # TODO
        then
          GIT_PASS+=( "SIGNED PASS: $_GIT_INFO" )
        else
          GIT_FAIL+=( "SIGNED FAIL: $_GIT_INFO" )
        fi
      fi

      # reset commit, body & file
      GIT_DATA=()
      GIT_BODY=()
      GIT_FILE=()
    fi
  done

  if [[ "$DUCT_GIT_CHECK_PASS" == true ]]
  then
    for VAL in "${GIT_PASS[@]}"
    do
      __duct_msg n "$VAL"
    done
  fi

  if [[ "$DUCT_GIT_CHECK_FAIL" == true ]]
  then
    for VAL in "${GIT_FAIL[@]}"
    do
      __duct_msg e "$VAL"
      (( GIT_RC+=1 ))
    done
  fi

  if [[ "$GIT_RC" -gt 0 ]]
  then
    return 1
  fi
}

# @func duct git changes

# @fvar Options to pass to `git diff` (defaults).
declare -r -a _DUCT_GIT_CHANGES_DIFF_OPTIONS=(
  --name-status
)

# @fvar Git changes (set at run-time).
declare -g -a DUCT_GIT_CHANGES=()

# @fvar Options to pass to `git diff` (--name-only or --name-status).
declare -g -a DUCT_GIT_CHANGES_DIFF_OPTIONS=( "${DUCT_GIT_CHANGES_DIFF_OPTIONS[@]:-${_DUCT_GIT_CHANGES_DIFF_OPTIONS[@]}}" )

# @fvar Base SHA (can also be a file).
declare -g DUCT_GIT_CHANGES_BASE="${DUCT_GIT_CHANGES_BASE:-}"

# @fvar Last SHA (can also be a file).
declare -g DUCT_GIT_CHANGES_LAST="${DUCT_GIT_CHANGES_LAST:-}"

# @fvar Print changes to stdtout.
declare -g DUCT_GIT_CHANGES_OUTPUT="${DUCT_GIT_CHANGES_OUTPUT:-false}"

# @fvar Path to get changes from.
declare -g DUCT_GIT_CHANGES_PATH="${DUCT_GIT_CHANGES_PATH:-$DUCT_GIT_WORKDIR}"

# @desc Show `git diff` changes between 2 SHA hashes.
# @intl false
# @life core
# @deps duct-msg duct-shell
# @opts [base-sha|base-sha-file] [last-sha|last-sha-file]
__duct_git_changes() {
  local GIT_CHANGES_BASE="${1:-$DUCT_GIT_CHANGES_BASE}"
  local GIT_CHANGES_LAST="${2:-$DUCT_GIT_CHANGES_LAST}"

  # set base sha from file
  if [[ -n "$GIT_CHANGES_BASE"  ]]
  then
    if [[ -s "$GIT_CHANGES_BASE" ]]
    then
      __duct_msg d "read base sha from $GIT_CHANGES_BASE"
      GIT_CHANGES_BASE="$( __duct_cat "$GIT_CHANGES_BASE"  )"
    fi
  fi

  if [[ -z "$GIT_CHANGES_BASE" || "$GIT_CHANGES_BASE" =~ ^([0]+)$ ]]
  then
    GIT_CHANGES_BASE="$( __duct_run git -C "$DUCT_GIT_CHANGES_PATH" show-branch --merge-base )"
  fi

  __duct_msg d "base: $GIT_CHANGES_BASE"

  # set last sha
  if [[ -n "$GIT_CHANGES_LAST" ]]
  then
    if [[ -s "$GIT_CHANGES_LAST" ]]
    then
      __duct_msg d "read last sha from $GIT_CHANGES_LAST"
      GIT_CHANGES_LAST="$( __duct_cat "$GIT_CHANGES_LAST"  )"
    fi
  fi

  if [[ -z "$GIT_CHANGES_LAST" ]]
  then
    GIT_CHANGES_LAST="$( __duct_run git -C "$DUCT_GIT_CHANGES_PATH" rev-parse --verify HEAD )"
  fi

  __duct_msg d "last: $GIT_CHANGES_LAST"

  __duct_msg n "set DUCT_GIT_CHANGES"
  readarray -t -n 0 DUCT_GIT_CHANGES < <(
    __duct_run git -C "$DUCT_GIT_CHANGES_PATH" diff "${DUCT_GIT_CHANGES_DIFF_OPTIONS[@]}" "${GIT_CHANGES_BASE}..${GIT_CHANGES_LAST}"
  )

  if [[ "$DUCT_GIT_CHANGES_OUTPUT" == true ]]
  then
    printf "%b\n" "${DUCT_GIT_CHANGES[@]}"
  fi
}

# @func duct git load

# @fvar List of duct-git requirements.
declare -r -a _DUCT_GIT_LOAD_REQUIREMENTS=(
  "$DUCT_GIT_BINARY"
)

# @fvar List of optional duct-git requirements.
declare -r -a _DUCT_GIT_LOAD_OPTIONALS=(
  "$DUCT_GIT_LFS_BINARY"
)

# @fvar Minimum supported git version.
declare -r _DUCT_GIT_LOAD_GIT_VERSION="2.25.0"

# @desc Check duct-git requirements.
# @intl true
# @life main
# @deps
# @opts
__duct_git_load() {
  __duct_intl

  local GIT_LOAD_RC=0

  __duct_bin_check "${_DUCT_GIT_LOAD_REQUIREMENTS[@]}" || GIT_LOAD_RC=$?

  if [[ "$GIT_LOAD_RC" -gt 0 ]]
  then
    return $GIT_LOAD_RC
  fi

  __duct_ver_check "$DUCT_GIT_BINARY" "$_DUCT_GIT_LOAD_GIT_VERSION" 3 || GIT_LOAD_RC=$?

  DUCT_BIN_CHECK_WARNING=true \
  __duct_bin_check "${_DUCT_GIT_LOAD_OPTIONALS[@]}"

  return $GIT_LOAD_RC
}
